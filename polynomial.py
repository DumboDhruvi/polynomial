"""
This is a polynomial class which contains function to be performed on them etc
make a dictonary imeplementation too
"""
import copy


class Polynomial:
    def __init__(self, l1=None):  # constructor
        self.terms = 0  # using 2d arrays instead welp! lol
        self.eqn = []  # even index represents power, corresponding index + 1 odd respresents coeffiecient
        if l1 is not None:
            self.value_update(l1)
            self.terms = len(self.eqn)

    def value_update(self, l1):  # always enter l1 with odd numbers of elements even are powers and odd is coefficient
        res = []
        for i in range(0, len(l1), 2):
            inter = [l1[i], l1[i + 1]]
            res.append(inter)
        self.eqn = res
        self.terms = len(res)
        self.sort_pow()

    def sort_pow(self): # inbuild function call only if list is not sorted for some reason
        self.eqn.sort(key=lambda x: -x[0])  # sorting on basis of powers

    def evaluate(self, val):
        res = 0
        for i in self.eqn:
            res += (val ** i[0]) * i[1]

        return res

    def __str__(self):  # printing, use str() function to access this! basically gives a user readable output
        res = ""
        for i in self.eqn:
            res += f"{i[1]}X^{i[0]} "

        return res.strip() + "\n"

    def copy_cons(self):  # copy constructor ussing copy module!
        return Polynomial(l1=copy.deepcopy(self.eqn))

    def __add__(self, other):
        result = Polynomial()
        i, j = 0, 0

        while i < len(self.eqn) and j < len(other.eqn):
            if self.eqn[i][0] == other.eqn[j][0]:
                result.eqn.append([self.eqn[i][0], self.eqn[i][1] + other.eqn[j][1]])
                i += 1
                j += 1
            elif self.eqn[i][0] > other.eqn[j][0]:
                result.eqn.append(self.eqn[i])
                i += 1
            else:
                result.eqn.append(other.eqn[j])
                j += 1

        # Add any remaining terms from both polynomials
        while i < len(self.eqn):
            result.eqn.append(self.eqn[i])
            i += 1

        while j < len(other.eqn):
            result.eqn.append(other.eqn[j])
            j += 1

        result.sort_pow()
        return result

    def __sub__(self, other):
        # just reverse the coefficient of other to minus?!?
        copied = other.copy_cons()
        for i in copied.eqn:
            i[1] *= -1
        ans = self + copied
        return ans

    def __mul__(self, other):
        res = Polynomial()
        # mutiply coefficients and add powers then add each poly generated by each term
        # a loop which takes elements of other
        j = 0
        i = 0
        while j < other.terms:
            inter = Polynomial()
            term = other.eqn[j]
            i = 0
            while i < self.terms:
                inter.eqn.append([self.eqn[i][0] + other.eqn[j][0], self.eqn[i][1] * other.eqn[j][1]])
                i += 1

            j += 1
            res += inter

        return res

    def differentiation(self):
        # you subtract one from power and multiply the coefficient with original power
        res = Polynomial()
        for i in self.eqn:
            if i[0] == 0:
                continue
            inter = [i[0] - 1, i[1] * i[0]]
            res.eqn.append(inter)

        return res

    def integration(self):
        # you add one to power and then divide by it!
        res = Polynomial()
        for i in self.eqn:
            res.eqn.append([i[0] + 1, i[1] / (i[0] + 1)])
        res.sort_pow()
        return res

    # def zeros_finder(self):
    #    ...


if __name__ == "__main__":
    s1 = Polynomial(l1=[1, 2, 2, 4])  # if user gives same powers then the internal dont add it
    s2 = Polynomial(l1=[1, 2, 0, 4])
    print(s1, s2, s1 * s2, s1.differentiation(), s1.integration())

# dont fuck with already made objects always return a new object, for gods sake!

# a program for showing decimal numbers only with up to three digits of aucuracy?1?


# a program for displaying decimal numbers as fractions ?!?
